{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "tktvdabC18-s"
   },
   "source": [
    "\n",
    "# Convolutional Neural Networks for Object Localization"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "niJxVteL18-y"
   },
   "source": [
    "In this notebook we will learn how to implement a convolutional neural network (CNN) regressor to localize digits of the MNIST dataset. We will use the Pytorch library for the implementation, compilation and training of the model.\n",
    "\n",
    "The input to our model is a $64 \\times 64$ image with a MNIST digit at any location, and the output of the model are four real numbers that define a bounding box (x, y, width, and height) around the digit."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "921un8bjnFV4"
   },
   "source": [
    "<table>\n",
    "    <tr>\n",
    "        <td><img src=\"data:image/png;base64, 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\"></td>\n",
    "        <td><span style=\"font-size:36px\">&#10142;</span></td>\n",
    "        <td><img src=\"data:image/png;base64, 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\"></td>\n",
    "    </tr>\n",
    "</table>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "exltrVHJnFV8"
   },
   "source": [
    "### Import necessary modules"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "azXeT9WlnFWA"
   },
   "outputs": [],
   "source": [
    "import torch\n",
    "import torch.nn as nn\n",
    "import torch.nn.functional as F\n",
    "import torch.optim as optim\n",
    "from torch.utils.data import Dataset, DataLoader\n",
    "from torchvision import datasets, transforms\n",
    "from torch.optim.lr_scheduler import StepLR\n",
    "\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from torchsummary import summary\n",
    "\n",
    "# setup cuda\n",
    "use_cuda = torch.cuda.is_available()\n",
    "device = torch.device(\"cuda\" if use_cuda else \"cpu\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "xJG-7PGF18-0"
   },
   "source": [
    "## Create a custom dataset"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "1xicFSzH18-1"
   },
   "source": [
    "First of all we need a custom dataset class to create our training/test samples. This class creates synthetic images by placing MNIST numbers (wich have a size $28 \\times 28$) at random locations of a black $64 \\times 64$ canvas image."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "DkhNGoQtqVHJ"
   },
   "source": [
    "Since Yann LeCun's server has been down, there have been issues in downloading MNIST over the past few days. So we'll download it from somewhere else."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "dpM9U6eUpjPJ",
    "outputId": "32dd2b9d-f8b8-48f1-a1e3-c7d092daeb51"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--2021-03-30 10:23:35--  http://www.di.ens.fr/~lelarge/MNIST.tar.gz\n",
      "Resolving www.di.ens.fr (www.di.ens.fr)... 129.199.99.14\n",
      "Connecting to www.di.ens.fr (www.di.ens.fr)|129.199.99.14|:80... connected.\n",
      "HTTP request sent, awaiting response... 302 Found\n",
      "Location: https://www.di.ens.fr/~lelarge/MNIST.tar.gz [following]\n",
      "--2021-03-30 10:23:35--  https://www.di.ens.fr/~lelarge/MNIST.tar.gz\n",
      "Connecting to www.di.ens.fr (www.di.ens.fr)|129.199.99.14|:443... connected.\n",
      "HTTP request sent, awaiting response... 200 OK\n",
      "Length: unspecified [application/x-gzip]\n",
      "Saving to: ‘MNIST.tar.gz.1’\n",
      "\n",
      "MNIST.tar.gz.1          [      <=>           ]  33.20M  29.4MB/s    in 1.1s    \n",
      "\n",
      "2021-03-30 10:23:36 (29.4 MB/s) - ‘MNIST.tar.gz.1’ saved [34813078]\n",
      "\n",
      "MNIST/\n",
      "MNIST/raw/\n",
      "MNIST/raw/train-labels-idx1-ubyte\n",
      "MNIST/raw/t10k-labels-idx1-ubyte.gz\n",
      "MNIST/raw/t10k-labels-idx1-ubyte\n",
      "MNIST/raw/t10k-images-idx3-ubyte.gz\n",
      "MNIST/raw/train-images-idx3-ubyte\n",
      "MNIST/raw/train-labels-idx1-ubyte.gz\n",
      "MNIST/raw/t10k-images-idx3-ubyte\n",
      "MNIST/raw/train-images-idx3-ubyte.gz\n",
      "MNIST/processed/\n",
      "MNIST/processed/training.pt\n",
      "MNIST/processed/test.pt\n"
     ]
    }
   ],
   "source": [
    "!wget www.di.ens.fr/~lelarge/MNIST.tar.gz\n",
    "!tar -zxvf MNIST.tar.gz"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "RhvETBzY18-2"
   },
   "outputs": [],
   "source": [
    "class MNISTlocalizationDataset(Dataset):\n",
    "    \"\"\"MNIST localization toy dataset.\"\"\"\n",
    "\n",
    "    def __init__(self, imgsize=(64,64), train=True, transform=None):\n",
    "        \"\"\"\n",
    "        Args:\n",
    "            imgsize (tuple (int,int), optional) - the size of generated images,\n",
    "                both width and height must be > 48\n",
    "            train (bool, optional) – If True, creates dataset from MNIST training\n",
    "                samples, otherwise from test\n",
    "            transform (callable, optional): Optional transform to be applied\n",
    "                on a sample.\n",
    "        \"\"\"\n",
    "        assert len(imgsize)==2 and imgsize[0] > 48 and imgsize[1] > 48\n",
    "        self.imgsize = imgsize\n",
    "        self.transform = transform\n",
    "        self.mnist = datasets.MNIST('./', train=train, download=True)\n",
    "\n",
    "    def __len__(self):\n",
    "        return self.mnist.data.shape[0]\n",
    "\n",
    "    def __getitem__(self, idx):\n",
    "        if torch.is_tensor(idx):\n",
    "            idx = idx.tolist()\n",
    "        image = torch.zeros(self.imgsize)\n",
    "        digit_img = self.mnist.data[idx,:,:]\n",
    "\n",
    "        # copy the MNIST digit into a random location\n",
    "        x_offset = np.random.randint(0,self.imgsize[1]-28)\n",
    "        y_offset = np.random.randint(0,self.imgsize[0]-28)\n",
    "        image[y_offset:y_offset+28,x_offset:x_offset+28] = digit_img\n",
    "        image = image.reshape((1,)+self.imgsize) # must be a tensor image of size (C, H, W)\n",
    "        \n",
    "        if self.transform:\n",
    "            image = self.transform(image)\n",
    "\n",
    "        # normalize the target values so they are real numbers from 0. to 1.\n",
    "        bbox = np.array([x_offset / self.imgsize[1], y_offset / self.imgsize[0], \n",
    "                         28. / self.imgsize[0], 28. / self.imgsize[1]], dtype=np.float32)\n",
    "        sample = {'image': image, 'bbox': bbox}\n",
    "\n",
    "        return sample"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "kE7Blf93nFWM"
   },
   "source": [
    "Now we can create the necessary Dataset and DataLoader objects as follows."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "gfgAf0yunFWN"
   },
   "outputs": [],
   "source": [
    "transform=transforms.Compose([transforms.Normalize((0.1307,), (0.3081,))])\n",
    "\n",
    "dataset1 = MNISTlocalizationDataset((64,64), train=True, transform=transform)\n",
    "dataset2 = MNISTlocalizationDataset((64,64), train=False, transform=transform)\n",
    "\n",
    "train_kwargs = {'batch_size': 64,   'shuffle': True,  'num_workers': 1,  'pin_memory': True}\n",
    "test_kwargs  = {'batch_size': 1000, 'shuffle': False, 'num_workers': 1,  'pin_memory': True}\n",
    "\n",
    "train_loader = DataLoader(dataset1, **train_kwargs)\n",
    "test_loader = DataLoader(dataset2, **test_kwargs)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "mS-cmCLP18-2"
   },
   "source": [
    "### Visualize some generated samples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 191
    },
    "id": "4aAtRuL-18-2",
    "outputId": "3e213d7d-1ee6-4396-a004-42aaae9b737a"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0 torch.Size([1, 64, 64]) (4,)\n",
      "1 torch.Size([1, 64, 64]) (4,)\n",
      "2 torch.Size([1, 64, 64]) (4,)\n",
      "3 torch.Size([1, 64, 64]) (4,)\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 4 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light",
      "tags": []
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "def show_bbox(image, bbox, pred=None):\n",
    "    \"\"\"Show image with bbox\"\"\"\n",
    "    image = image.squeeze()\n",
    "    plt.imshow(image)\n",
    "\n",
    "    # plot the ground truth bounding box\n",
    "    imgsize = image.shape\n",
    "    bbox *= [imgsize[1],imgsize[0],imgsize[0],imgsize[1]]\n",
    "    plt.plot([bbox[0],bbox[0]+bbox[3],bbox[0]+bbox[3],bbox[0],bbox[0]],\n",
    "             [bbox[1],bbox[1],bbox[1]+bbox[2],bbox[1]+bbox[2],bbox[1]], c='r')\n",
    "\n",
    "    if pred is not None: \n",
    "        # plot the predicted bounding box (if provided)\n",
    "        pred *= [imgsize[1],imgsize[0],imgsize[0],imgsize[1]]\n",
    "        plt.plot([pred[0],pred[0]+pred[3],pred[0]+pred[3],pred[0],pred[0]],\n",
    "                 [pred[1],pred[1],pred[1]+pred[2],pred[1]+pred[2],pred[1]], c='b')\n",
    "    \n",
    "fig = plt.figure()\n",
    "for i in range(len(dataset1)):\n",
    "    sample = dataset1[i]\n",
    "    print(i, sample['image'].shape, sample['bbox'].shape)\n",
    "    ax = plt.subplot(1, 4, i + 1)\n",
    "    plt.tight_layout()\n",
    "    ax.set_title('Sample #{}'.format(i))\n",
    "    ax.axis('off')\n",
    "    show_bbox(**sample)\n",
    "\n",
    "    if i == 3:\n",
    "        plt.show()\n",
    "        break"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "aszWIV0m18-5",
    "outputId": "0090ce77-6e89-4374-ae5d-b3f2cc5d22bd"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Size of training data: 60000\n",
      "Size of test data: 10000\n"
     ]
    }
   ],
   "source": [
    "# check the size of the dataset\n",
    "print(\"Size of training data: {}\".format(len(dataset1)))\n",
    "print(\"Size of test data: {}\".format(len(dataset2)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "gmOpSBhE18-3"
   },
   "source": [
    "We have 60,000 images for training and 10,000 for testing. The image size is $64 \\times 64$ pixels and they have only one channel (greyscale images)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "DyLPtyuE18-7"
   },
   "source": [
    "## Create the CNN regression model\n",
    "\n",
    "We will use a simple CNN model with two convolutional layers, one pooling layer, and two fully connected layers. We will use also Dropout to help regularizing the model. \n",
    "\n",
    "Notice that the output layer has four neurons with a `sigmoid` activation, so our model produces at its outputs four real numbers (x,y,width, and height)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "s7dNybnGphHF",
    "outputId": "7e08a8e7-d8bd-4922-9370-5604001ef21f"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "----------------------------------------------------------------\n",
      "        Layer (type)               Output Shape         Param #\n",
      "================================================================\n",
      "            Conv2d-1            [-1, 8, 32, 32]             208\n",
      "              ReLU-2            [-1, 8, 32, 32]               0\n",
      "            Conv2d-3           [-1, 16, 16, 16]           1,168\n",
      "              ReLU-4           [-1, 16, 16, 16]               0\n",
      "            Conv2d-5             [-1, 32, 8, 8]           4,640\n",
      "              ReLU-6             [-1, 32, 8, 8]               0\n",
      "            Conv2d-7             [-1, 32, 4, 4]           9,248\n",
      "              ReLU-8             [-1, 32, 4, 4]               0\n",
      " AdaptiveAvgPool2d-9             [-1, 32, 1, 1]               0\n",
      "          Flatten-10                   [-1, 32]               0\n",
      "           Linear-11                    [-1, 4]             132\n",
      "          Sigmoid-12                    [-1, 4]               0\n",
      "================================================================\n",
      "Total params: 15,396\n",
      "Trainable params: 15,396\n",
      "Non-trainable params: 0\n",
      "----------------------------------------------------------------\n",
      "Input size (MB): 0.02\n",
      "Forward/backward pass size (MB): 0.23\n",
      "Params size (MB): 0.06\n",
      "Estimated Total Size (MB): 0.30\n",
      "----------------------------------------------------------------\n"
     ]
    }
   ],
   "source": [
    "def get_model():\n",
    "    return nn.Sequential(\n",
    "        nn.Conv2d( 1, 8, 5, padding=2,stride=2), nn.ReLU(),\n",
    "        nn.Conv2d( 8,16, 3, padding=1,stride=2), nn.ReLU(),\n",
    "        nn.Conv2d(16,32, 3, padding=1,stride=2), nn.ReLU(),\n",
    "        nn.Conv2d(32,32, 3, padding=1,stride=2), nn.ReLU(),\n",
    "        nn.AdaptiveAvgPool2d(1),\n",
    "        nn.Flatten(),\n",
    "        nn.Linear(32,4),\n",
    "        nn.Sigmoid())\n",
    "\n",
    "summary(get_model(),(1,64,64),device=\"cpu\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "ndYgcQkW18-8"
   },
   "source": [
    "### Define the training method\n",
    "\n",
    "For training our CNN regression model we will use the L1 loss, which takes the mean element-wise absolute value difference.\n",
    "\n",
    "See <a href=\"https://pytorch.org/docs/stable/generated/torch.nn.L1Loss.html#torch.nn.L1Loss\">`torch.nn.L1Loss`</a> for details."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "u2LLkt5218-8"
   },
   "outputs": [],
   "source": [
    "def train(model, device, train_loader, optimizer, epoch, scheduler=None):\n",
    "    model.train()\n",
    "    loss_values = []\n",
    "    for batch_idx, sample_batched in enumerate(train_loader):\n",
    "        data = sample_batched['image']\n",
    "        target = sample_batched['bbox']\n",
    "        data, target = data.to(device), target.to(device)\n",
    "        optimizer.zero_grad()\n",
    "        output = model(data)\n",
    "        loss = F.l1_loss(output, target)\n",
    "        loss_values.append(loss)\n",
    "        loss.backward()\n",
    "        optimizer.step()\n",
    "        if batch_idx % log_interval == 0:\n",
    "            print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format(\n",
    "                epoch, batch_idx * len(data), len(train_loader.dataset),\n",
    "                100. * batch_idx / len(train_loader), loss.item()))\n",
    "        if scheduler is not None:\n",
    "            scheduler.step()\n",
    "    return loss_values"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "oOvIRgNG18-8"
   },
   "source": [
    "### Train the model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "7yGqDf0w18-9",
    "outputId": "023a5eed-5200-4afd-c66a-4ff0132b8870"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Train Epoch: 1 [0/60000 (0%)]\tLoss: 0.266870\n",
      "Train Epoch: 1 [6400/60000 (11%)]\tLoss: 0.068973\n",
      "Train Epoch: 1 [12800/60000 (21%)]\tLoss: 0.049243\n",
      "Train Epoch: 1 [19200/60000 (32%)]\tLoss: 0.050470\n",
      "Train Epoch: 1 [25600/60000 (43%)]\tLoss: 0.044253\n",
      "Train Epoch: 1 [32000/60000 (53%)]\tLoss: 0.037643\n",
      "Train Epoch: 1 [38400/60000 (64%)]\tLoss: 0.024683\n",
      "Train Epoch: 1 [44800/60000 (75%)]\tLoss: 0.032685\n",
      "Train Epoch: 1 [51200/60000 (85%)]\tLoss: 0.026372\n",
      "Train Epoch: 1 [57600/60000 (96%)]\tLoss: 0.021756\n",
      "Train Epoch: 2 [0/60000 (0%)]\tLoss: 0.019765\n",
      "Train Epoch: 2 [6400/60000 (11%)]\tLoss: 0.017576\n",
      "Train Epoch: 2 [12800/60000 (21%)]\tLoss: 0.019312\n",
      "Train Epoch: 2 [19200/60000 (32%)]\tLoss: 0.023731\n",
      "Train Epoch: 2 [25600/60000 (43%)]\tLoss: 0.018612\n",
      "Train Epoch: 2 [32000/60000 (53%)]\tLoss: 0.012639\n",
      "Train Epoch: 2 [38400/60000 (64%)]\tLoss: 0.013896\n",
      "Train Epoch: 2 [44800/60000 (75%)]\tLoss: 0.010530\n",
      "Train Epoch: 2 [51200/60000 (85%)]\tLoss: 0.011073\n",
      "Train Epoch: 2 [57600/60000 (96%)]\tLoss: 0.009041\n",
      "Train Epoch: 3 [0/60000 (0%)]\tLoss: 0.009216\n",
      "Train Epoch: 3 [6400/60000 (11%)]\tLoss: 0.009860\n",
      "Train Epoch: 3 [12800/60000 (21%)]\tLoss: 0.009838\n",
      "Train Epoch: 3 [19200/60000 (32%)]\tLoss: 0.009515\n",
      "Train Epoch: 3 [25600/60000 (43%)]\tLoss: 0.007155\n",
      "Train Epoch: 3 [32000/60000 (53%)]\tLoss: 0.008487\n",
      "Train Epoch: 3 [38400/60000 (64%)]\tLoss: 0.008554\n",
      "Train Epoch: 3 [44800/60000 (75%)]\tLoss: 0.007935\n",
      "Train Epoch: 3 [51200/60000 (85%)]\tLoss: 0.008336\n",
      "Train Epoch: 3 [57600/60000 (96%)]\tLoss: 0.007715\n",
      "Train Epoch: 4 [0/60000 (0%)]\tLoss: 0.007361\n",
      "Train Epoch: 4 [6400/60000 (11%)]\tLoss: 0.006727\n",
      "Train Epoch: 4 [12800/60000 (21%)]\tLoss: 0.007270\n",
      "Train Epoch: 4 [19200/60000 (32%)]\tLoss: 0.008328\n",
      "Train Epoch: 4 [25600/60000 (43%)]\tLoss: 0.006326\n",
      "Train Epoch: 4 [32000/60000 (53%)]\tLoss: 0.005662\n",
      "Train Epoch: 4 [38400/60000 (64%)]\tLoss: 0.006309\n",
      "Train Epoch: 4 [44800/60000 (75%)]\tLoss: 0.005266\n",
      "Train Epoch: 4 [51200/60000 (85%)]\tLoss: 0.006355\n",
      "Train Epoch: 4 [57600/60000 (96%)]\tLoss: 0.005734\n",
      "Train Epoch: 5 [0/60000 (0%)]\tLoss: 0.005485\n",
      "Train Epoch: 5 [6400/60000 (11%)]\tLoss: 0.005571\n",
      "Train Epoch: 5 [12800/60000 (21%)]\tLoss: 0.005549\n",
      "Train Epoch: 5 [19200/60000 (32%)]\tLoss: 0.006036\n",
      "Train Epoch: 5 [25600/60000 (43%)]\tLoss: 0.004391\n",
      "Train Epoch: 5 [32000/60000 (53%)]\tLoss: 0.005000\n",
      "Train Epoch: 5 [38400/60000 (64%)]\tLoss: 0.004866\n",
      "Train Epoch: 5 [44800/60000 (75%)]\tLoss: 0.004888\n",
      "Train Epoch: 5 [51200/60000 (85%)]\tLoss: 0.004431\n",
      "Train Epoch: 5 [57600/60000 (96%)]\tLoss: 0.004230\n"
     ]
    }
   ],
   "source": [
    "model = get_model().to(device)\n",
    "\n",
    "lr = 1e-2\n",
    "optimizer = optim.Adam(model.parameters(), lr=lr)\n",
    "\n",
    "epochs = 5\n",
    "scheduler = optim.lr_scheduler.OneCycleLR(optimizer, lr, epochs=epochs, steps_per_epoch=len(train_loader))\n",
    "\n",
    "log_interval = 100 # how many batches to wait before logging training status\n",
    "\n",
    "loss_history = []\n",
    "for epoch in range(1, epochs + 1):\n",
    "    loss_values = train(model, device, train_loader, optimizer, epoch, scheduler)\n",
    "    loss_history += loss_values"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "mIMOMKRh18--"
   },
   "source": [
    "### Plot the loss over time"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 282
    },
    "id": "Jb2ocuvo18--",
    "outputId": "09b9a779-56bd-47da-b169-4b3a39d98a2d"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x7f3085909a10>]"
      ]
     },
     "execution_count": 13,
     "metadata": {
      "tags": []
     },
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light",
      "tags": []
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(np.arange(len(loss_history)), loss_history)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "5tWPmXhk18--"
   },
   "source": [
    "## Evaluate the model\n",
    "\n",
    "Finally, we can use the trained model to predict a bounding box for any given image. Let's see how to make predictions for the first four images of the test set."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 122
    },
    "id": "JMecAtU618--",
    "outputId": "153a5bb3-f8dd-427a-ad93-92ed45d9eeea"
   },
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 4 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light",
      "tags": []
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "model.eval()\n",
    "\n",
    "fig = plt.figure()\n",
    "for i in range(5):\n",
    "    # get a random index\n",
    "    idx = np.random.randint(0,len(dataset2))\n",
    "    sample = dataset2[idx]\n",
    "    ax = plt.subplot(1, 4, i + 1)\n",
    "    plt.tight_layout()\n",
    "    ax.set_title('Sample #{}'.format(i))\n",
    "    ax.axis('off')\n",
    "    \n",
    "    # predict the bounding box for a given image\n",
    "    data = sample['image']\n",
    "    data = data.reshape((1,)+data.shape) # shape must be (b,c,h,w)\n",
    "    data = data.to(device)\n",
    "    with torch.no_grad():\n",
    "        output = model(data)\n",
    "        \n",
    "    sample['pred'] = output[0].cpu().numpy()\n",
    "    show_bbox(**sample)\n",
    "\n",
    "    if i == 3:\n",
    "        plt.show()\n",
    "        break"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "xIulY-aDnFWx"
   },
   "source": [
    "We appreciate that the predicted bounding boxes (blue) are good aproximations of the ground truth (red).\n",
    "\n",
    "In order to measure whether the results are correct or not in the entire test set we need to implement a performance measure based on the Intersection over Union (IoU) of the ground truth and predicted bounding boxes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "mQAjMYu0nFWz"
   },
   "outputs": [],
   "source": [
    "def IoU(pred, target, iou_threshold = 0.7):\n",
    "    # determine the coordinates of the intersection rectangle\n",
    "    x_left = np.maximum(pred[:,0], target[:,0])\n",
    "    y_top = np.maximum(pred[:,1], target[:,1])\n",
    "    x_right = np.minimum(pred[:,0]+pred[:,2], target[:,0]+target[:,2])\n",
    "    y_bottom = np.minimum(pred[:,1]+pred[:,3], target[:,1]+target[:,3])\n",
    "    \n",
    "    intersection_area = (x_right - x_left) * (y_bottom - y_top)\n",
    "    \n",
    "    # compute the areas of the union\n",
    "    pred_area = pred[:,2] * pred[:,3]\n",
    "    target_area =  target[:,2] *  target[:,3]\n",
    "    \n",
    "    union_area = pred_area + target_area - intersection_area\n",
    "    \n",
    "    iou = intersection_area / union_area\n",
    "    \n",
    "    return iou>iou_threshold"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "id": "e-eALiMsnFW1"
   },
   "source": [
    "### Define the test method"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "mGRtscbXnFW2",
    "outputId": "1a318823-9fcf-4d5b-e112-2b800a792061"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Test set: Average loss: 0.0047, Accuracy: 9972/10000 (100%)\n",
      "\n"
     ]
    }
   ],
   "source": [
    "def test(model, device, test_loader):\n",
    "    model.eval()\n",
    "    test_loss = 0\n",
    "    correct = 0\n",
    "    with torch.no_grad():\n",
    "        for batch_idx, sample_batched in enumerate(test_loader):\n",
    "            data = sample_batched['image']\n",
    "            target = sample_batched['bbox']\n",
    "            data, target = data.to(device), target.to(device)\n",
    "            output = model(data)\n",
    "            test_loss += F.l1_loss(output, target).item()\n",
    "            \n",
    "            # count the number of prediction with an IoU above a certain threshold\n",
    "            correct += np.sum(IoU(output.cpu().numpy(), target.cpu().numpy(), iou_threshold = 0.7))\n",
    "\n",
    "    test_loss /= (len(test_loader.dataset)/test_loader.batch_size)\n",
    "\n",
    "    print('\\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\\n'.format(\n",
    "        test_loss, correct, len(test_loader.dataset),\n",
    "        100. * correct / len(test_loader.dataset)))\n",
    "    \n",
    "\n",
    "# call the test method\n",
    "test(model, device, test_loader)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 285
    },
    "id": "MFi3JR4OnFW5",
    "outputId": "da83b9e6-6d5d-43f3-e3e6-9703b1b11b65",
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[0.04725623 0.33146966 0.43751213 0.43748653]] [[0.078125 0.390625 0.4375   0.4375  ]] [False]\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light",
      "tags": []
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Find wrong prediction and display it\n",
    "\n",
    "model.eval()\n",
    "\n",
    "fig = plt.figure()\n",
    "plt.tight_layout()\n",
    "ax.axis('off')\n",
    "ax = plt.subplot(1, 1, 1)\n",
    "for i in range(len(dataset2)):\n",
    "    sample = dataset2[i]\n",
    "    \n",
    "    # predict the bounding box for a given image\n",
    "    data = sample['image']\n",
    "    data = data.reshape((1,)+data.shape) # shape must be (b,c,h,w)\n",
    "    data = data.to(device)\n",
    "    with torch.no_grad():\n",
    "        output = model(data)\n",
    "    \n",
    "    target = sample['bbox'].reshape((1,4))\n",
    "    iou= IoU(output.cpu().numpy(), target, iou_threshold = 0.7)\n",
    "    \n",
    "    if not iou:\n",
    "        print(output.cpu().numpy(), target,iou)\n",
    "        sample['pred'] = output[0].cpu().numpy()\n",
    "        show_bbox(**sample)\n",
    "        break\n",
    "\n",
    "plt.show()\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "accelerator": "GPU",
  "colab": {
   "collapsed_sections": [],
   "name": "CNN_MNIST_Localization - Part0 - Aditya Rana .ipynb",
   "provenance": [],
   "toc_visible": true
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
